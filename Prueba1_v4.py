#!/usr/bin/env python
# -*- coding:utf-8 -*-

#COMANDO PARA EJECUTAR: sudo -E python3 Prueba1_py.py test
# ############################################################################
#  license :
# ============================================================================
#
#  File :        Prueba1_py.py
#
#  Project :     
#
# This file is part of Tango device class.
# 
# Tango is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tango is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tango.  If not, see <http://www.gnu.org/licenses/>.
# 
#
#  $Author :      juancarlos$
#
#  $Revision :    1.0$
#
#  $Date :        14 - 06 - 24$
#
#  $HeadUrl :     TFM_MUISE.upv.es$
# ============================================================================
#            This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
# ############################################################################

__all__ = ["Prueba1_py", "Prueba1_pyClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
import mmap
import struct
import os
#from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QPushButton
#from PyQt5 import uic


#from taurus.qt.qtgui.taurusgui.utils import PanelDescription
#from taurus.qt.qtgui.panel import TaurusForm


#GUI_NAME = 'MyGui'

# Corrige la importación y la creación de PanelDescription
#panel = PanelDescription('Foo',
                        # classname='taurus.external.qt.Qt:QWidget')

# Add additional import
#----- PROTECTED REGION ID(Prueba1_py.additionnal_import) ENABLED START -----#

#----- PROTECTED REGION END -----#	//	Prueba1_py.additionnal_import

# Device States Description
# No states for this device

#################################################################################
#################################################################################
     

# Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
memory_size = 4096
global ID 

    

#ID1
##Lectura de direccion de memoria de ID
# Dirección de memoria a la que deseamos acceder
memory_address = 0x43C2001C


# Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
memory_size = 4096

# Desplazamiento dentro de la página de memoria
page_size = mmap.PAGESIZE
page_base = (memory_address // page_size) * page_size
page_offset = memory_address % page_size

try:
    # Abre /dev/mem con permisos de lectura/escritura
    with open("/dev/mem", "rb") as f:
        # Mapear la memoria
        mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)
        
        # Leer 4 bytes desde la dirección especificada
        mem.seek(page_offset)
        data = mem.read(4)
        
        # Interpretar los bytes leídos como un entero de 32 bits
        value = struct.unpack('<I', data)[0]
        
        hex_value = hex(value)
        hex_string = format(value, 'x')
        global ID
        ID=str(hex_string)
        
        print(f"Valor leído desde 0x{memory_address:X}: {value} (hex: {hex_value}) (string: {hex_string}) (ID: {ID})")
        
        # Cerrar el mapeo de memoria
        mem.close()
except PermissionError as e:
    print("PermissionError:", e)
    print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
    
    
##Fin lectura memoria valor ID
             
#ID2
##Lectura de direccion de memoria de ID
# Dirección de memoria a la que deseamos acceder
memory_address = 0x43CA001C
global ID2
# Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
memory_size = 4096

# Desplazamiento dentro de la página de memoria
page_size = mmap.PAGESIZE
page_base = (memory_address // page_size) * page_size
page_offset = memory_address % page_size

try:
    # Abre /dev/mem con permisos de lectura/escritura
    with open("/dev/mem", "rb") as f:
        # Mapear la memoria
        mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)
        
        # Leer 4 bytes desde la dirección especificada
        mem.seek(page_offset)
        data = mem.read(4)
        
        # Interpretar los bytes leídos como un entero de 32 bits
        value = struct.unpack('<I', data)[0]
        
        hex_value = hex(value)
        hex_string = format(value, 'x')
        global ID2
        ID2=str(hex_string)
        
        print(f"Valor leído desde 0x{memory_address:X}: {value} (hex: {hex_value}) (string: {hex_string}) (ID2: {ID2})")
        
        # Cerrar el mapeo de memoria
        mem.close()
except PermissionError as e:
    print("PermissionError:", e)
    print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
    
    
##Fin lectura memoria valor ID 
             
#ID3
##Lectura de direccion de memoria de ID
# Dirección de memoria a la que deseamos acceder
memory_address = 0x43CB001C
global ID3
# Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
memory_size = 4096

# Desplazamiento dentro de la página de memoria
page_size = mmap.PAGESIZE
page_base = (memory_address // page_size) * page_size
page_offset = memory_address % page_size

try:
    # Abre /dev/mem con permisos de lectura/escritura
    with open("/dev/mem", "rb") as f:
        # Mapear la memoria
        mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)
        
        # Leer 4 bytes desde la dirección especificada
        mem.seek(page_offset)
        data = mem.read(4)
        
        # Interpretar los bytes leídos como un entero de 32 bits
        value = struct.unpack('<I', data)[0]
        
        hex_value = hex(value)
        hex_string = format(value, 'x')
        global ID3
        ID3=str(hex_string)
        
        print(f"Valor leído desde 0x{memory_address:X}: {value} (hex: {hex_value}) (string: {hex_string}) (ID3: {ID3})")
        
        # Cerrar el mapeo de memoria
        mem.close()
except PermissionError as e:
    print("PermissionError:", e)
    print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
    
    
##Fin lectura memoria valor ID  

#ID4
##Lectura de direccion de memoria de ID
# Dirección de memoria a la que deseamos acceder
memory_address = 0x43CB001C
global ID4
# Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
memory_size = 4096

# Desplazamiento dentro de la página de memoria
page_size = mmap.PAGESIZE
page_base = (memory_address // page_size) * page_size
page_offset = memory_address % page_size

try:
    # Abre /dev/mem con permisos de lectura/escritura
    with open("/dev/mem", "rb") as f:
        # Mapear la memoria
        mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)
        
        # Leer 4 bytes desde la dirección especificada
        mem.seek(page_offset)
        data = mem.read(4)
        
        # Interpretar los bytes leídos como un entero de 32 bits
        value = struct.unpack('<I', data)[0]
        
        hex_value = hex(value)
        hex_string = format(value, 'x')
        global ID4
        ID4=str(hex_string)
        
        print(f"Valor leído desde 0x{memory_address:X}: {value} (hex: {hex_value}) (string: {hex_string}) (ID4: {ID4})")
        
        # Cerrar el mapeo de memoria
        mem.close()
except PermissionError as e:
    print("PermissionError:", e)
    print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
    
    
##Fin lectura memoria valor ID             


#################################################################################
#################################################################################
#Trigger 1
class Prueba1_py (PyTango.LatestDeviceImpl):
    """"""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_variables

    def __init__(self, cl, name):
        PyTango.LatestDeviceImpl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Prueba1_py.init_device(self)
        self.set_state(PyTango.DevState.RUNNING)
        #----- PROTECTED REGION ID(Prueba1_py.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Prueba1_py.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Lectura_read = ID
        self.attr_ID_read = ID
        self.attr_ContadorTrigger1_read = 0
        
        #----- PROTECTED REGION ID(Prueba1_py.init_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(Prueba1_py.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.always_executed_hook

    # -------------------------------------------------------------------------
    #    Prueba1_py read/write attribute methods
    # -------------------------------------------------------------------------

          
    def read_ID(self, attr):
        self.debug_stream("In read_ID()")
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
        attr.set_value(self.attr_ID_read)
        
        #----- PROTECTED REGION END -----#	//	Nada.ID_read
        
    def is_ID_allowed(self, attr):
        self.debug_stream("In is_ID_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.ON,
                PyTango.DevState.OFF,
                PyTango.DevState.UNKNOWN])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(Nada.is_ID_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Nada.is_ID_allowed
        return state_ok
    
    def write_Dutty1(self, attr):
        self.debug_stream("In write_Dutty1()")
        data_w = attr.get_write_value()
        
         #----- PROTECTED REGION ID(Prueba1_py.write_Dutty) ENABLED START -----#
        ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C20008
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I',data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

##Fin escritura memoria triggers
        
     #----- PROTECTED REGION END -----#	//	Prueba1_py.write_Dutty
    def write_Offset1(self, attr):
        self.debug_stream("In write_Offset1()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C20004
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")



        #----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
        
        
    def write_Periodo1(self, attr):
        self.debug_stream("In write_Periodo1()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C2000C
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
            
    def write_Control1(self, attr):
        self.debug_stream("In write_Control1()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C20000
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write
        
       
        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def write_Trigger1(self, attr):
                           
        self.debug_stream("In write_Trigger1()")
        data_w = attr.get_write_value()

        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C20014
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write


        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir

                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def read_ContadorTrigger1(self, attr):
          
        
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
                                  
        self.debug_stream("In read_ContadorTrigger1()")
        attr.set_value(self.attr_ContadorTrigger1_read)
        #Contador trigger 1
        # Dirección de memoria a la que deseamos acceder
        memory_address_contadortrigger1 = 0x43C20018
        # Desplazamiento dentro de la página de memoria
        page_size = mmap.PAGESIZE
        page_base = (memory_address_contadortrigger1 // page_size) * page_size
        page_offset = memory_address_contadortrigger1 % page_size

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb") as f:
                # Mapear la memoria
                mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)

                # Leer 4 bytes desde la dirección especificada
                mem.seek(page_offset)
                data = mem.read(4)

                # Interpretar los bytes leídos como un entero de 32 bits
                value = struct.unpack('<I', data)[0]
                self.attr_ContadorTrigger1_read = value


                #print(f"Valor leído desde 0x{memory_address_contadortrigger1:X}: {value}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger1:X}: {GlobalContadorTrigger1}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger1:X}: {self.attr_ContadorTrigger1_read}")

                # Cerrar el mapeo de memoria
                mem.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")





##Fin lectura contador triggers 1    
   
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(Prueba1_py.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.read_attr_hardware


    # -------------------------------------------------------------------------
    #    Prueba1_py command methods
    # -------------------------------------------------------------------------
    

    #----- PROTECTED REGION ID(Prueba1_py.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.programmer_methods
 
class Trigger2 (PyTango.LatestDeviceImpl):
    """"""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_variables

    def __init__(self, cl, name):
        PyTango.LatestDeviceImpl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Trigger2.init_device(self)
        self.set_state(PyTango.DevState.RUNNING)
        #----- PROTECTED REGION ID(Prueba1_py.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Prueba1_py.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Lectura_read = ID2
        self.attr_ID2_read = ID2
        self.attr_ContadorTrigger2_read = 0

        #----- PROTECTED REGION ID(Prueba1_py.init_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(Prueba1_py.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.always_executed_hook

    # -------------------------------------------------------------------------
    #    Prueba1_py read/write attribute methods
    # -------------------------------------------------------------------------

                           
    
    def read_ID2(self, attr):
        self.debug_stream("In read_ID()")
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
        attr.set_value(self.attr_ID2_read)
        
        #----- PROTECTED REGION END -----#	//	Nada.ID_read
        
    def is_ID2_allowed(self, attr):
        self.debug_stream("In is_ID2_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.ON,
                PyTango.DevState.OFF,
                PyTango.DevState.UNKNOWN])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(Nada.is_ID_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Nada.is_ID_allowed
        return state_ok
    
    def write_Dutty2(self, attr):
        self.debug_stream("In write_Dutty2()")
        data_w = attr.get_write_value()
        
         #----- PROTECTED REGION ID(Prueba1_py.write_Dutty) ENABLED START -----#
        ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CA0008
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I',data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

##Fin escritura memoria triggers
        
     #----- PROTECTED REGION END -----#	//	Prueba1_py.write_Dutty
    def write_Offset2(self, attr):
        self.debug_stream("In write_Offset2()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CA0004
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")



        #----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
        
        
    def write_Periodo2(self, attr):
        self.debug_stream("In write_Periodo1()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CA000C
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
            
    def write_Control2(self, attr):
        self.debug_stream("In write_Control2()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CA0000
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write
        
       
        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def write_Trigger2(self, attr):
        self.debug_stream("In write_Trigger2()")
        data_w = attr.get_write_value()

        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CA0014
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write


        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir

                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def read_ContadorTrigger2(self, attr):
          
        
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
                                  
        self.debug_stream("In read_ContadorTrigger2()")
        attr.set_value(self.attr_ContadorTrigger2_read)
        #Contador trigger 2
        # Dirección de memoria a la que deseamos acceder
        memory_address_contadortrigger2 = 0x43CA0018
        # Desplazamiento dentro de la página de memoria
        page_size = mmap.PAGESIZE
        page_base = (memory_address_contadortrigger2 // page_size) * page_size
        page_offset = memory_address_contadortrigger2 % page_size

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb") as f:
                # Mapear la memoria
                mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)

                # Leer 4 bytes desde la dirección especificada
                mem.seek(page_offset)
                data = mem.read(4)

                # Interpretar los bytes leídos como un entero de 32 bits
                value = struct.unpack('<I', data)[0]
                self.attr_ContadorTrigger2_read = value


                #print(f"Valor leído desde 0x{memory_address_contadortrigger2:X}: {value}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger2:X}: {GlobalContadorTrigger2}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger2:X}: {self.attr_ContadorTrigger2_read}")

                # Cerrar el mapeo de memoria
                mem.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")





##Fin lectura contador triggers 2                             

        #----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
     
   


#----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
        
   
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(Prueba1_py.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.read_attr_hardware


    # -------------------------------------------------------------------------
    #    Prueba1_py command methods
    # -------------------------------------------------------------------------
    

    #----- PROTECTED REGION ID(Prueba1_py.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.programmer_methods
 
class Trigger3(PyTango.LatestDeviceImpl):
    """"""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_variables

    def __init__(self, cl, name):
        PyTango.LatestDeviceImpl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Prueba1_py.init_device(self)
        self.set_state(PyTango.DevState.RUNNING)
        #----- PROTECTED REGION ID(Prueba1_py.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Prueba1_py.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Lectura_read = ID3
        self.attr_ID_read = ID3
        self.attr_ContadorTrigger3_read = 0

        #----- PROTECTED REGION ID(Prueba1_py.init_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(Prueba1_py.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.always_executed_hook

    # -------------------------------------------------------------------------
    #    Prueba1_py read/write attribute methods
    # -------------------------------------------------------------------------

    
    def read_ID3(self, attr):
        self.debug_stream("In read_ID()")
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
        attr.set_value(self.attr_ID_read)
        
        #----- PROTECTED REGION END -----#	//	Nada.ID_read
        
    def is_ID_allowed(self, attr):
        self.debug_stream("In is_ID_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.ON,
                PyTango.DevState.OFF,
                PyTango.DevState.UNKNOWN])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(Nada.is_ID_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Nada.is_ID_allowed
        return state_ok
    
    def write_Dutty3(self, attr):
        self.debug_stream("In write_Dutty3()")
        data_w = attr.get_write_value()
        
         #----- PROTECTED REGION ID(Prueba1_py.write_Dutty) ENABLED START -----#
        ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CB0008
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I',data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

##Fin escritura memoria triggers
        
     #----- PROTECTED REGION END -----#	//	Prueba1_py.write_Dutty
    def write_Offset3(self, attr):
        self.debug_stream("In write_Offset3()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CB0004
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")



        #----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
        
        
    def write_Periodo3(self, attr):
        self.debug_stream("In write_Periodo3()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CB000C
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
            
    def write_Control3(self, attr):
        self.debug_stream("In write_Control3()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CB0000
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write
        
       
        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def write_Trigger3(self, attr):
        self.debug_stream("In write_Trigger3()")
        data_w = attr.get_write_value()

        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CB0014
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write


        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir

                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def read_ContadorTrigger3(self, attr):
          
        
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
                                  
        self.debug_stream("In read_ContadorTrigger3()")
        attr.set_value(self.attr_ContadorTrigger3_read)
        #Contador trigger 3
        # Dirección de memoria a la que deseamos acceder
        memory_address_contadortrigger3 = 0x43CB0018
        # Desplazamiento dentro de la página de memoria
        page_size = mmap.PAGESIZE
        page_base = (memory_address_contadortrigger3 // page_size) * page_size
        page_offset = memory_address_contadortrigger3 % page_size

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb") as f:
                # Mapear la memoria
                mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)

                # Leer 4 bytes desde la dirección especificada
                mem.seek(page_offset)
                data = mem.read(4)

                # Interpretar los bytes leídos como un entero de 32 bits
                value = struct.unpack('<I', data)[0]
                self.attr_ContadorTrigger3_read = value


                #print(f"Valor leído desde 0x{memory_address_contadortrigger3:X}: {value}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger3:X}: {GlobalContadorTrigger3}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger3:X}: {self.attr_ContadorTrigger3_read}")

                # Cerrar el mapeo de memoria
                mem.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")





##Fin lectura contador triggers 3
     
   


#----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
        
   
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(Prueba1_py.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.read_attr_hardware

class Trigger4 (PyTango.LatestDeviceImpl):
    """"""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_variables

    def __init__(self, cl, name):
        PyTango.LatestDeviceImpl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Prueba1_py.init_device(self)
        self.set_state(PyTango.DevState.RUNNING)
        #----- PROTECTED REGION ID(Prueba1_py.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Prueba1_py.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Lectura_read = ID4
        self.attr_ID_read = ID4
        self.attr_ContadorTrigger4_read = 0

        #----- PROTECTED REGION ID(Prueba1_py.init_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(Prueba1_py.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.always_executed_hook

    # -------------------------------------------------------------------------
    #    Prueba1_py read/write attribute methods
    # -------------------------------------------------------------------------

    
    def read_ID4(self, attr):
        self.debug_stream("In read_ID()")
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
        attr.set_value(self.attr_ID_read)
        
        #----- PROTECTED REGION END -----#	//	Nada.ID_read
        
    def is_ID_allowed(self, attr):
        self.debug_stream("In is_ID_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.ON,
                PyTango.DevState.OFF,
                PyTango.DevState.UNKNOWN])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(Nada.is_ID_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Nada.is_ID_allowed
        return state_ok
    
    def write_Dutty4(self, attr):
        self.debug_stream("In write_Dutty4()")
        data_w = attr.get_write_value()
        
         #----- PROTECTED REGION ID(Prueba1_py.write_Dutty) ENABLED START -----#
        ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CC0008
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I',data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

##Fin escritura memoria triggers
        
     #----- PROTECTED REGION END -----#	//	Prueba1_py.write_Dutty
    def write_Offset4(self, attr):
        self.debug_stream("In write_Offset4()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CC0004
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")



        #----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
        
        
    def write_Periodo4(self, attr):
        self.debug_stream("In write_Periodo4()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CC000C
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
            
    def write_Control4(self, attr):
        self.debug_stream("In write_Control4()")
        data_w = attr.get_write_value()
        
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CC0000
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write
        
       
        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir
                
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def write_Trigger4(self, attr):
        self.debug_stream("In write_Trigger4()")
        data_w = attr.get_write_value()

        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43CC0014
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write


        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)

                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)
                data_to_write = struct.pack('<I', data_w)  # Ejemplo de dato a escribir

                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")

    def read_ContadorTrigger4(self, attr):
          
        
        #----- PROTECTED REGION ID(Nada.ID_read) ENABLED START -----#
                                  
        self.debug_stream("In read_ContadorTrigger4()")
        attr.set_value(self.attr_ContadorTrigger4_read)
        #Contador trigger 4
        # Dirección de memoria a la que deseamos acceder
        memory_address_contadortrigger4 = 0x43CC0018
        # Desplazamiento dentro de la página de memoria
        page_size = mmap.PAGESIZE
        page_base = (memory_address_contadortrigger4 // page_size) * page_size
        page_offset = memory_address_contadortrigger4 % page_size

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb") as f:
                # Mapear la memoria
                mem = mmap.mmap(f.fileno(), memory_size, mmap.MAP_SHARED, mmap.PROT_READ, offset=page_base)

                # Leer 4 bytes desde la dirección especificada
                mem.seek(page_offset)
                data = mem.read(4)

                # Interpretar los bytes leídos como un entero de 32 bits
                value = struct.unpack('<I', data)[0]
                self.attr_ContadorTrigger4_read = value


                #print(f"Valor leído desde 0x{memory_address_contadortrigger4:X}: {value}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger4:X}: {GlobalContadorTrigger4}")
                #print(f"Valor leído desde 0x{memory_address_contadortrigger4:X}: {self.attr_ContadorTrigger4_read}")

                # Cerrar el mapeo de memoria
                mem.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")





##Fin lectura contador triggers 1    
     
   


#----- PROTECTED REGION END -----#	//	Prueba1_py.Escritura_write
        
   
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(Prueba1_py.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.read_attr_hardware


    # -------------------------------------------------------------------------
    #    Prueba1_py command methods
    # -------------------------------------------------------------------------
    

    #----- PROTECTED REGION ID(Prueba1_py.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.programmer_methods

    # -------------------------------------------------------------------------
    #    Prueba1_py command methods
    # -------------------------------------------------------------------------
    

    #----- PROTECTED REGION ID(Prueba1_py.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.programmer_methods
   
class Interlock (PyTango.LatestDeviceImpl):                         
    def __init__(self, cl, name):
        PyTango.LatestDeviceImpl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Interlock.init_device(self)
        self.set_state(PyTango.DevState.RUNNING)
        #----- PROTECTED REGION ID(Prueba1_py.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Prueba1_py.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        
        #----- PROTECTED REGION ID(Prueba1_py.init_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")     
                           
    def write_Enable(self, attr):
        self.debug_stream("In write_Enable()")
        data_wi = attr.get_write_value()
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que desamos acceder
        memory_address_write = 0x43C00004
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)


                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)

                print("",data_wi)

                data_to_write = struct.pack('<I', data_wi)  # Ejemplo de dato a escribir
                print("",data_to_write)
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")
                           
    def write_Nivel(self, attr):
        self.debug_stream("In write_Nivel()")
        data_wi = attr.get_write_value()
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C00008
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)


                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)

                print("",data_wi)

                data_to_write = struct.pack('<I', data_wi)  # Ejemplo de dato a escribir
                print("",data_to_write)
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")  
                           
    def write_Prioridad(self, attr):
        self.debug_stream("In write_Prioridad()")
        data_wi = attr.get_write_value()
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C0000C
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)


                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)

                print("",data_wi)

                data_to_write = struct.pack('<I', data_wi)  # Ejemplo de dato a escribir
                print("",data_to_write)
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")       
                           
    def write_Activacion(self, attr):
        self.debug_stream("In write_Activacion()")
        data_wi = attr.get_write_value()
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C00010
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)


                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)

                print("",data_wi)

                data_to_write = struct.pack('<I', data_wi)  # Ejemplo de dato a escribir
                print("",data_to_write)
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")   
                           
    def write_Inputsoftware(self, attr):
        self.debug_stream("In write_Inputsoftware()")
        data_wi = attr.get_write_value()
        #----- PROTECTED REGION ID(Prueba1_py.Escritura_write) ENABLED START -----#
         ##Escritura de direccion de memoria de triggers

        # Dirección de memoria a la que deseamos acceder
        memory_address_write = 0x43C00014
        # Tamaño de la región de memoria a mapear (puede variar según tus necesidades)
        memory_size_write = 4096

        # Desplazamiento dentro de la página de memoria
        page_size_write = mmap.PAGESIZE
        page_base_write = (memory_address_write // page_size_write) * page_size_write
        page_offset_write = memory_address_write % page_size_write

        try:
            # Abre /dev/mem con permisos de lectura/escritura
            with open("/dev/mem", "rb+") as f:
                # Mapear la memoria
                mem_write = mmap.mmap(f.fileno(), memory_size_write, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=page_base_write)


                # Leer 4 bytes desde la dirección especificada
                mem_write.seek(page_offset_write)

                print("",data_wi)

                data_to_write = struct.pack('<I', data_wi)  # Ejemplo de dato a escribir
                print("",data_to_write)
                mem_write.write(data_to_write)


                # Cerrar el mapeo de memoria
                mem_write.close()
        except PermissionError as e:
            print("PermissionError:", e)
            print("Asegúrate de tener permisos adecuados o haber configurado correctamente los parámetros del kernel.")  
                           
class Prueba1_pyClass(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_class_variables


    #    Class Properties
    class_property_list = {
        
        }


    #    Device Properties
    device_property_list = {
       
        
        
        }


    #    Command definitions
    cmd_list = {  
  
        
        }


    #    Attribute definitions
    attr_list = {
         'ID':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "ID del trigger 1",
            } ],
         'Control1':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Control del trigger 1",
            } ],
        'Offset1':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Offset del trigger 1",
            } ],
        'Dutty1':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Dutty del trigger 1",
            } ],       
        'Periodo1':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Periodo del trigger 1",
            } ],
        
        'Trigger1':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Numero de triggers a enviar",
            } ],
        
        'ContadorTrigger1':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Numero de triggers enviados",
            } ],
                        
        
        }

class Trigger2Class(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_class_variables


    #    Class Properties
    class_property_list = {
        
        }


    #    Device Properties
    device_property_list = {
       
        
        
        }


    #    Command definitions
    cmd_list = {  
  
        
        }


    #    Attribute definitions
    attr_list = {
         'ID2':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "ID del trigger 2",
            } ],
         'Control2':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Control del trigger 2",
            } ],
        'Offset2':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Offset del trigger 2",
            } ],
        'Dutty2':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Dutty del trigger 2",
            } ],       
        'Periodo2':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Periodo del trigger 2",
            } ],
         'Trigger2':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Numero de triggers a enviar",
            } ],
        
        'ContadorTrigger2':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Numero de triggers enviados",
            } ],
         
                        
        
        }
class Trigger3Class(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_class_variables


    #    Class Properties
    class_property_list = {
        
        }


    #    Device Properties
    device_property_list = {
       
        
        
        }


    #    Command definitions
    cmd_list = {  
  
        
        }


    #    Attribute definitions
    attr_list = {
         'ID3':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "ID del trigger 3",
            } ],
         'Control3':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Control del trigger 3",
            } ],
        'Offset3':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Offset del trigger 3",
            } ],
        'Dutty3':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Dutty del trigger 3",
            } ],       
        'Periodo3':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Periodo del trigger 3",
            } ],
        'Trigger3':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Numero de triggers a enviar",
            } ],
        
        'ContadorTrigger3':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Numero de triggers enviados",
            } ],
         
         
                        
        
        }
class Trigger4Class(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_class_variables


    #    Class Properties
    class_property_list = {
        
        }


    #    Device Properties
    device_property_list = {
       
        
        
        }


    #    Command definitions
    cmd_list = {  
  
        
        }


    #    Attribute definitions
    attr_list = {
         'ID4':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "ID del trigger 4",
            } ],
         'Control4':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Control del trigger 4",
            } ],
        'Offset4':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Offset del trigger 4",
            } ],
        'Dutty4':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Dutty del trigger 4",
            } ],       
        'Periodo4':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Periodo del trigger 4",
            } ],
        'Trigger4':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Numero de triggers a enviar",
            } ],
        
        'ContadorTrigger4':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Numero de triggers enviados",
            } ],
         
                        
        
        }
class InterlockClass(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Prueba1_py.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Prueba1_py.global_class_variables


    #    Class Properties
    class_property_list = {
        
        }


    #    Device Properties
    device_property_list = {
       
        
        
        }


    #    Command definitions
    cmd_list = {  
  
        
        }


    #    Attribute definitions
    attr_list = {
         'Enable':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Enable",
            } ],
         'Nivel':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Nivel",
            } ],
        'Prioridad':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Prioridad",
            } ],
        'Activacion':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Activacion",
            } ],       
        'Inputsoftware':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "Input software",
            } ],
         
                        
        
        }                
                           
def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(Prueba1_pyClass, Prueba1_py, 'Trigger1')
        py.add_class(Trigger2Class, Trigger2, 'Trigger2')
        py.add_class(Trigger3Class, Trigger3, 'Trigger3')
        py.add_class(Trigger4Class, Trigger4, 'Trigger4')
                        
        py.add_class(InterlockClass, Interlock, 'Interlock')
                           
        

        #----- PROTECTED REGION ID(Prueba1_py.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Prueba1_py.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed as e:
        print ('-------> Received a DevFailed exception:', e)
    except Exception as e:
        print ('-------> An unforeseen exception occured....', e)
                               
 


                        
if __name__ == '__main__':
    print("Conexión a la base de datos de tango-controls: REALIZADA\r")
    print("Conexión a la placa pynq-z2: REALIZADA\r")
    print("Preparado para la señalización digital\r")
  

    main()
